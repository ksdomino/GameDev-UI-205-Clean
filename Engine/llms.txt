# CANVAS ENGINE - LLM CONTEXT FILE
# Last Updated: 2026-01-17
# Purpose: Enable AI agents to work on this engine without reading every file
# Related: See /SceneEditor/llms.txt for the GameDev UI tool
# Version: 2.8 - Added dual input controls section, clarified Capacitor purpose

================================================================================
ðŸš€ QUICK START (READ THIS FIRST!)
================================================================================

To run the full GameDev system, you need 3 SERVERS running simultaneously.

STEP 1: Kill any existing servers on these ports (ALWAYS DO THIS FIRST):
  lsof -ti :5174,:5175,:5176 | xargs kill -9 2>/dev/null

STEP 2: Install dependencies (if node_modules missing):
  cd Engine && npm install
  cd SceneEditor && npm install

STEP 3: Start all 3 servers:

  Terminal 1 - Engine (game runtime):
    cd Engine && npm run dev
    â†’ http://localhost:5174

  Terminal 2 - SceneEditor Backend (file I/O, WebSocket):
    cd SceneEditor && npm run server
    â†’ http://localhost:5176

  Terminal 3 - SceneEditor UI (React app):
    cd SceneEditor && npm run dev
    â†’ http://localhost:5175

IMPORTANT: The Debug Panel in the SceneEditor UI embeds the Engine via iframe.
All three must be running to test games visually from the UI.

To run ONLY the game (no UI editing):
  lsof -ti :5174 | xargs kill -9 2>/dev/null
  cd Engine && npm run dev
  â†’ http://localhost:5174

================================================================================
ðŸ“‹ FILE ANNOTATION STANDARD
================================================================================

When creating or editing files, include this header comment to help future AI:

JavaScript/JSX:
/**
 * @fileoverview [Brief description]
 * @context Engine/llms.txt
 */

JSON:
{
  "_context": "Engine/llms.txt",
  "_description": "[Brief description]",
  ...
}

AI agents should PRESERVE these headers when editing files.


================================================================================
ðŸŽ¯ PRIME DIRECTIVE
================================================================================

**Goal: Create high-quality JavaScript/Canvas games wrapped with Capacitor for
iOS App Store and Google Play Store distribution.**

This engine is designed for PRODUCTION MOBILE GAMES, not web demos. All games
should be built as native-quality experiences that happen to use web technology.
Capacitor wraps the Canvas game into a native app shell.

All development decisions must support this goal. When vibecoding games or
modifying the engine, optimize for:
1. Mobile performance (60fps, low battery)
2. High retention (meta-progression, daily rewards, session length)
3. Proven genres with market fit (see Target Genres below)

================================================================================
TARGET GENRES (2026 Market Fit)
================================================================================

Based on 2025-2026 mobile gaming market analysis, prioritize these genres:

### Tier 1: Best Fit for This Engine
| Genre | Examples | Why It Fits |
|-------|----------|-------------|
| **Rogue-lite Action** | Vampire Survivors, Brotato | Object pooling, waves, short sessions |
| **Hybrid-Casual** | Games with simple core + meta | Easy to vibecode, high retention |
| **Match-3 / Puzzle** | Royal Match, Candy Crush | Grid logic, no complex physics |
| **Merge Games** | Gossip Harbor | Drag-drop, simple state |

### Tier 2: Possible with Extensions
| Genre | Gap to Close |
|-------|--------------|
| Beat-em-up / Brawler | Needs state machines, hitbox system |
| Card Battler | Needs card system, possibly PvP backend |
| Idle/Simulation | Needs offline progress, timer systems |

### Tier 3: Out of Scope
- MOBA, Battle Royale, AR games (require netcode, native SDKs, or platform features)

================================================================================
DOCUMENTATION INDEX
================================================================================

/docs/ASSET_PIPELINE_AND_PERFORMANCE.md
  - Image specifications (PO2 rule, 2048px max sheets)
  - Tiling standards for scrolling backgrounds
  - Sprite-sheet JSON schema for animations
  - Mobile performance guardrails (deltaTime, object pooling, culling)
  - Audio standards (MP3, mobile unlock pattern)
  - Memory management (cache clearing between scenes)

================================================================================
OVERVIEW
================================================================================

This is a vanilla JavaScript HTML5 Canvas game engine for 2D mobile games.
- Internal Resolution: 1080 x 1920 (9:16 portrait)
- All game logic uses canvas coordinates (0-1080 x, 0-1920 y)
- Letterbox scaling automatically adapts to any device
- Screens are called "Scenes" in this engine
- Built with Vite for development and production builds

================================================================================
PROJECT STRUCTURE
================================================================================

/
â”œâ”€â”€ index.html              # Entry HTML with mobile meta tags
â”œâ”€â”€ package.json            # npm dependencies (vite)
â”œâ”€â”€ vite.config.js          # Vite configuration
â”œâ”€â”€ llms.txt                # THIS FILE - AI context
â”œâ”€â”€ README.md               # Basic readme
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ ASSET_PIPELINE_AND_PERFORMANCE.md
â”‚   â””â”€â”€ PLATINUM_10_STACK.md  # 2026 indie-pro toolstack guide
â””â”€â”€ src/
    â”œâ”€â”€ css/
    â”‚   â””â”€â”€ style.css       # Fullscreen canvas CSS, touch handling
    â””â”€â”€ js/
        â”œâ”€â”€ main.js         # Entry point - creates Engine, loads BootScene
        â”œâ”€â”€ core/
        â”‚   â”œâ”€â”€ Engine.js       # Main engine class
        â”‚   â”œâ”€â”€ SceneManager.js # Scene switching
        â”‚   â”œâ”€â”€ LayerManager.js # 7-layer render system (with static caching)
        â”‚   â”œâ”€â”€ InputHandler.js # Touch/mouse/keyboard input
        â”‚   â”œâ”€â”€ AssetLoader.js  # Image/audio/video preloading
        â”‚   â”œâ”€â”€ AudioManager.js # Music and SFX playback
        â”‚   â”œâ”€â”€ ObjectPool.js   # Object recycling for performance
        â”‚   â”œâ”€â”€ WaveSpawner.js  # Timed enemy/object spawning
        â”‚   â”œâ”€â”€ SaveManager.js  # localStorage persistence
        â”‚   â”œâ”€â”€ Collision.js    # Circle/rect collision utilities
        â”‚   â”œâ”€â”€ ActorStateMachine.js # Finite state machine for actors
        â”‚   â”œâ”€â”€ CameraEffects.js    # Screen shake, zoom, follow
        â”‚   â”œâ”€â”€ FirebaseService.js  # Auth, Crashlytics, Push (AI-First Stack)
        â”‚   â”œâ”€â”€ PlayFabService.js   # Economy, Inventory, Leaderboards (AI-First Stack)
        â”‚   â”œâ”€â”€ MixpanelService.js  # Behavioral analytics (AI-First Stack)
        â”‚   â”œâ”€â”€ TextureAtlas.js     # TexturePacker sprite atlas loader
        â”‚   â””â”€â”€ TiledLoader.js      # Tiled map editor JSON loader
        â”œâ”€â”€ entities/
        â”‚   â”œâ”€â”€ Sprite.js       # Base sprite class
        â”‚   â””â”€â”€ Button.js       # UI button class
        â”œâ”€â”€ ui/
        â”‚   â”œâ”€â”€ UpgradeModal.js # Rogue-lite upgrade selection
        â”‚   â”œâ”€â”€ VirtualJoystick.js # Twin-stick touch controls
        â”‚   â”œâ”€â”€ XPSystem.js     # Experience and leveling
        â”‚   â”œâ”€â”€ TimerUI.js      # Countdown/count-up display
        â”‚   â”œâ”€â”€ DailyRewards.js # Daily login rewards system
        â”‚   â””â”€â”€ ParticleSystem.js # Visual effects and particles
        â””â”€â”€ scenes/
            â”œâ”€â”€ Scene.js        # Base scene class
            â”œâ”€â”€ BootScene.js    # Initial loading scene
            â””â”€â”€ BlankScene.js   # Empty template scene

================================================================================
CORE CLASSES
================================================================================

## Engine (src/js/core/Engine.js)
Main game engine class. Instantiated in main.js.

Constructor: new Engine(canvas, width=1080, height=1920)

Properties:
- canvas, ctx          : Canvas element and 2D context
- width, height        : Internal resolution (1080x1920)
- inputHandler         : InputHandler instance
- layerManager         : LayerManager instance
- sceneManager         : SceneManager instance
- audioManager         : AudioManager instance
- assetLoader          : AssetLoader instance
- isRunning            : Boolean game loop state

Methods:
- start()              : Start the game loop
- stop()               : Stop the game loop
- gameLoop(time)       : Main loop (called via requestAnimationFrame)
- update(deltaTime)    : Update game state (deltaTime in seconds)
- draw()               : Clear canvas and render all layers
- setupLetterboxScaling() : Maintains aspect ratio on resize
- getLayerManager()    : Returns layerManager
- getInputHandler()    : Returns inputHandler
- getSceneManager()    : Returns sceneManager
- getAudioManager()    : Returns audioManager
- getAssetLoader()     : Returns assetLoader

Global Access: window.gameEngine (for debugging)

--------------------------------------------------------------------------------

## SceneManager (src/js/core/SceneManager.js)
Manages scene lifecycle and transitions.

Constructor: new SceneManager(engine)

Properties:
- engine               : Engine reference
- currentScene         : Active Scene instance
- scenes               : Map of registered scenes by name

Methods:
- register(name, scene)    : Register scene by name for later switching
- switchTo(sceneName)      : Switch to registered scene by name
- changeScene(newScene)    : Direct scene change (calls exit/enter lifecycle)
- getCurrentScene()        : Returns current scene
- update(deltaTime)        : Calls currentScene.update(deltaTime)

Scene Change Flow:
1. currentScene.exit() called
2. newScene.setEngine(engine) called
3. layerManager.clearAll() clears all layers
4. await newScene.enter() called (ASYNC - waits for asset loading)
5. currentScene = newScene
6. newScene.populateLayers() called

IMPORTANT: Scene switching is now ASYNC. All calls to switchTo() and changeScene()
must be awaited to ensure assets are fully loaded before rendering begins.

--------------------------------------------------------------------------------

## LayerManager (src/js/core/LayerManager.js)
Handles layered rendering with fixed z-order.

Constructor: new LayerManager(canvas)

THE 7 RENDER LAYERS (bottom to top):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer Index â”‚ Name         â”‚ Purpose                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0           â”‚ BG_FAR       â”‚ Far parallax backgrounds       â”‚
â”‚ 1           â”‚ BG_NEAR      â”‚ Near parallax backgrounds      â”‚
â”‚ 2           â”‚ VIDEO_IMAGE  â”‚ Full-screen images/video       â”‚
â”‚ 3           â”‚ SHAPES       â”‚ Primitive shapes, particles    â”‚
â”‚ 4           â”‚ SPRITES      â”‚ Game characters and objects    â”‚
â”‚ 5           â”‚ TEXT         â”‚ In-game text, HUD elements     â”‚
â”‚ 6           â”‚ UI_BUTTONS   â”‚ Touch buttons (always on top)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Methods:
- addToLayer(entity, layerName)      : Add entity to layer (entity must have render(ctx) method)
- removeFromLayer(entity, layerName) : Remove entity from layer
- clearLayer(layerName)              : Clear single layer
- clearAll()                         : Clear all layers
- render(ctx)                        : Render all layers in order

Entity Requirement: Any object added to a layer MUST have a render(ctx) method.

Example custom render object:
```javascript
const bg = {
  render: (ctx) => {
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, 1080, 1920);
  }
};
this.layerManager.addToLayer(bg, 'BG_FAR');
```

--------------------------------------------------------------------------------

## InputHandler (src/js/core/InputHandler.js)
Unified touch/mouse/keyboard input with coordinate transformation.

Constructor: new InputHandler(canvas, internalWidth=1080, internalHeight=1920)

Properties:
- mouse.x, mouse.y     : Current position in canvas coordinates (0-1080, 0-1920)
- mouse.down           : Boolean - currently pressed
- mouse.pressed        : Boolean - just pressed this frame (one-shot)
- mouse.released       : Boolean - just released this frame (one-shot)
- touches              : Array of {id, x, y, startX, startY}
- keys                 : Object mapping key codes to boolean state

Methods:
- isKeyDown(code)      : Check if key is down (e.g., 'KeyW', 'ArrowUp', 'Space')
- isMouseDown()        : Check if mouse/touch is down
- getMousePos()        : Returns {x, y} in canvas coordinates
- getTouches()         : Returns array of active touches
- screenToCanvas(x,y)  : Convert screen coords to canvas coords
- updateTransform()    : Recalculate scaling (called on resize)
- resetFrame()         : Reset pressed/released flags (called by engine)

IMPORTANT: Mobile browsers require user interaction before playing audio.
InputHandler auto-resumes the AudioContext in touchstart via AudioManager.initAudioContext().

IMPORTANT: mouse.pressed and mouse.released are only true for ONE FRAME.
Check them in update() before they reset.

================================================================================
DUAL INPUT CONTROLS (CRITICAL FOR TESTING)
================================================================================

Games are played on mobile via TOUCH but tested in browser via MOUSE/KEYBOARD.
ALWAYS implement BOTH input methods so games work in both environments.

**Pattern for Player Movement:**
```javascript
update(deltaTime) {
  // TOUCH/MOUSE: Direct position control (works on both)
  if (this.inputHandler.mouse.down) {
    this.player.x = this.inputHandler.mouse.x;
  }

  // KEYBOARD: Arrow keys / WASD for browser testing
  if (this.inputHandler.isKeyDown('ArrowLeft') || this.inputHandler.isKeyDown('KeyA')) {
    this.player.x -= this.player.speed * deltaTime;
  }
  if (this.inputHandler.isKeyDown('ArrowRight') || this.inputHandler.isKeyDown('KeyD')) {
    this.player.x += this.player.speed * deltaTime;
  }
}
```

**Pattern for Actions (Jump, Shoot, etc.):**
```javascript
update(deltaTime) {
  // TOUCH/MOUSE: Tap anywhere or tap button
  if (this.inputHandler.mouse.pressed) {
    this.jump();
  }

  // KEYBOARD: Space bar for browser testing
  if (this.inputHandler.isKeyDown('Space')) {
    this.jump();
  }
}
```

**Standard Key Mappings for Browser Testing:**
| Action        | Touch             | Keyboard                    |
|---------------|-------------------|-----------------------------|
| Move Left     | Drag/Touch left   | ArrowLeft, KeyA             |
| Move Right    | Drag/Touch right  | ArrowRight, KeyD            |
| Move Up       | Drag/Touch up     | ArrowUp, KeyW               |
| Move Down     | Drag/Touch down   | ArrowDown, KeyS             |
| Primary Action| Tap               | Space, Enter                |
| Secondary     | Long press/Swipe  | Shift, KeyE                 |
| Pause         | Pause button      | Escape, KeyP                |

**IMPORTANT**: The InputHandler normalizes touch and mouse into the same interface.
`mouse.x/y` works for both. `isKeyDown()` only works in browser but that's fine
for testing. On mobile, only touch input is available.

--------------------------------------------------------------------------------

## AssetLoader (src/js/core/AssetLoader.js)
Preloads images, audio, and video files.

Constructor: new AssetLoader()

Properties:
- images               : Map of loaded images
- audio                : Map of loaded audio
- videos               : Map of loaded videos
- loadedCount          : Number of assets loaded
- totalCount           : Total assets in current batch
- onProgress           : Callback(progress, loaded, total)
- onComplete           : Callback when batch complete

Methods:
- loadImage(id, path)      : Load single image, returns Promise<Image>
- loadAudio(id, path)      : Load single audio, returns Promise<HTMLAudioElement>
- loadVideo(id, path)      : Load single video, returns Promise<HTMLVideoElement>
- loadImages(assets)       : Batch load [{id, path}, ...], returns Promise
- loadAudioFiles(assets)   : Batch load audio files, returns Promise
- loadVideos(assets)       : Batch load video files, returns Promise
- getImage(id)             : Get loaded image by id
- getAudio(id)             : Get loaded audio by id
- getVideo(id)             : Get loaded video by id
- startBatch()             : Reset counters for new batch
- reset()                  : Reset loader state

Example usage in scene:
```javascript
async init() {
  const loader = this.engine.assetLoader;
  loader.onProgress = (p) => console.log(`Loading: ${Math.floor(p*100)}%`);
  await loader.loadImages([
    { id: 'bg', path: '/assets/images/background.png' },
    { id: 'player', path: '/assets/images/player.png' }
  ]);
}
```

--------------------------------------------------------------------------------

## AudioManager (src/js/core/AudioManager.js)
Handles music and sound effect playback.

Constructor: new AudioManager()

Properties:
- musicVolume          : 0-1 volume for music
- sfxVolume            : 0-1 volume for sound effects
- currentMusic         : Currently playing music element

Methods:
- playMusic(id, loop=true)    : Play music from /assets/music/{id}
- stopMusic()                 : Stop current music
- playSFX(id, volume=null)    : Play SFX from /assets/sfx/{id}
- playBeep(freq, dur, type)   : Synthesize a beep using Web Audio API (freq, duration, oscillator type)
- initAudioContext()          : Initialize/resume AudioContext (called automatically by InputHandler)
- setMusicVolume(volume)      : Set music volume (0-1)
- setSFXVolume(volume)        : Set SFX volume (0-1)

Expected Asset Paths:
- Music: /assets/music/{filename}
- SFX: /assets/sfx/{filename}

IMPORTANT: Mobile browsers require user interaction before playing audio.
Trigger audio on first touch/click event.

================================================================================
ENTITY CLASSES
================================================================================

## Sprite (src/js/entities/Sprite.js)
Base class for game entities.

Constructor: new Sprite(x=0, y=0, width=0, height=0)

Properties:
- x, y                 : Position (top-left corner in Sprite class itself)
- width, height        : Dimensions
- rotation             : Rotation in radians
- scaleX, scaleY       : Scale factors (1 = normal)
- alpha                : Opacity (0-1)
- image                : Image object or null
- color                : Fallback color if no image ('#ffffff')
- visible              : Whether to render
- active               : Whether entity is active

Methods:
- setImage(imageOrPath)    : Set image from Image object or path string
- setColor(color)          : Set fallback color
- update(deltaTime)        : Override in subclasses for logic
- render(ctx)              : Renders sprite (handles transforms)
- contains(x, y)           : Point-in-bounds collision check
- getCenterX()             : Returns center X position
- getCenterY()             : Returns center Y position

Rendering: Sprite renders around its center point with transforms applied.
If no image, renders a colored rectangle.

IMPORTANT - Center-Based Coordinates in ConfigurableScene:
When using ConfigurableScene (JSON-driven scenes), all entity x,y positions
are CENTER-BASED. The scene internally converts to top-left for Sprite/Shape.
This matches the Scene Editor's visual drag-and-drop behavior where (540, 960)
places an entity at the center of the 1080x1920 canvas.

--------------------------------------------------------------------------------

## Button (src/js/entities/Button.js)
UI button with click detection.

Constructor: new Button(x=0, y=0, w=200, h=80, text='', color='#4a90e2', alpha=1, onClick=null)

Properties:
- x, y                 : Position (top-left)
- w, h                 : Width and height
- text                 : Button label
- color                : Background color
- alpha                : Opacity
- onClick              : Callback function(button)
- visible              : Whether to render/detect clicks

Methods:
- render(ctx)              : Renders button with text
- checkClick(mouseX, mouseY) : Check if click is inside, triggers onClick

Example usage:
```javascript
const playBtn = new Button(390, 800, 300, 100, 'PLAY', '#4a90e2', 1, () => {
  this.sceneManager.switchTo('GameScene');
});
this.layerManager.addToLayer(playBtn, 'UI_BUTTONS');

// In update():
if (this.inputHandler.mouse.pressed) {
  playBtn.checkClick(this.inputHandler.mouse.x, this.inputHandler.mouse.y);
}
```

================================================================================
SCENE CLASS
================================================================================

## Scene (src/js/scenes/Scene.js)
Base class for all game scenes/screens.

Constructor: new Scene(name)

Properties:
- name                 : Scene identifier
- engine               : Engine reference (set by setEngine)
- layerManager         : LayerManager reference
- inputHandler         : InputHandler reference
- sceneManager         : SceneManager reference
- isActive             : Currently active
- isInitialized        : Has init() been called

Lifecycle Methods (override in subclasses):
- init()               : One-time initialization (load assets, create entities)
- enter()              : Called when scene becomes active
- exit()               : Called when leaving scene
- update(deltaTime)    : Game logic (called every frame)
- populateLayers()     : Add entities to layers after scene change

Helper Methods:
- setEngine(engine)    : Called by SceneManager
- switchScene(name)    : Switch to another registered scene

SCENE TEMPLATE:
```javascript
import { Scene } from './Scene.js';

export class MyScene extends Scene {
  constructor() {
    super('MyScene');
  }

  init() {
    // Load assets, create entities (called once)
  }

  enter() {
    super.enter();
    // Called every time scene becomes active
  }

  exit() {
    super.exit();
    // Cleanup when leaving
  }

  populateLayers() {
    // Add entities to layers
    // this.layerManager.addToLayer(entity, 'LAYER_NAME');
  }

  update(deltaTime) {
    // Game logic, input handling
    // deltaTime is in SECONDS (0.016 for 60fps)
  }
}
```

================================================================================
ASSET SPECIFICATIONS
================================================================================

## Image Sizes

| Asset Type                      | Dimensions        | Notes                          |
|---------------------------------|-------------------|--------------------------------|
| Full-screen background (port.)  | 1080 Ã— 1920       | Exact internal resolution      |
| Full-screen background (land.)  | 1920 Ã— 1080       | For landscape games            |
| Vertical scroll background      | 1080 Ã— 2160+      | Height > 1920 for seamless     |
| Horizontal scroll background    | 2160+ Ã— 1920      | Width > 1080 for seamless      |
| Parallax layer (far)            | 1080 Ã— 1920+      | Can be taller for scroll       |
| Parallax layer (near)           | 1080 Ã— 1920+      | Can be taller for scroll       |

## Spritesheet Specifications

| Tile Size   | Use Case                                    |
|-------------|---------------------------------------------|
| 64 Ã— 64     | Small icons, collectibles, particles        |
| 128 Ã— 128   | Medium sprites, enemies, items              |
| 256 Ã— 256   | Large sprites, player characters            |
| 512 Ã— 512   | Full-body characters with detail            |
| 256 Ã— 512   | Tall character sprites                      |

Maximum spritesheet dimensions: 2048Ã—2048 (safe), 4096Ã—4096 (modern devices)
Format: PNG with transparency

## Spritesheet Layout
- Grid-based: all frames same size
- Rows can represent different animations (idle, walk, attack)
- Columns represent frames within an animation
- Example: 8 columns Ã— 4 rows = 8 frames per animation, 4 animations

## Audio Specifications

| Type            | Format          | Notes                           |
|-----------------|-----------------|--------------------------------|
| Background music| MP3, OGG, AAC   | MP3 most compatible            |
| Sound effects   | MP3, OGG, WAV   | Short files, MP3 recommended   |

File paths:
- Music: /assets/music/{filename}
- SFX: /assets/sfx/{filename}

================================================================================
COMMON PATTERNS
================================================================================

## Creating a Title Screen Scene
```javascript
import { Scene } from './Scene.js';
import { Button } from '../entities/Button.js';
import { Sprite } from '../entities/Sprite.js';

export class TitleScene extends Scene {
  constructor() {
    super('TitleScene');
    this.background = null;
    this.playButton = null;
  }

  async init() {
    // Load assets
    await this.engine.assetLoader.loadImages([
      { id: 'titleBg', path: '/assets/images/title_bg.png' }
    ]);
  }

  populateLayers() {
    // Background (1080x1920)
    const bgImage = this.engine.assetLoader.getImage('titleBg');
    this.background = new Sprite(0, 0, 1080, 1920);
    this.background.setImage(bgImage);
    this.layerManager.addToLayer(this.background, 'BG_FAR');

    // Play button
    this.playButton = new Button(340, 1200, 400, 120, 'PLAY', '#e74c3c', 1, () => {
      this.engine.audioManager.playSFX('click.mp3');
      this.sceneManager.switchTo('GameScene');
    });
    this.layerManager.addToLayer(this.playButton, 'UI_BUTTONS');
  }

  update(deltaTime) {
    // Check for button clicks
    if (this.inputHandler.mouse.pressed) {
      const { x, y } = this.inputHandler.mouse;
      this.playButton.checkClick(x, y);
    }
  }
}
```

## Registering and Switching Scenes
```javascript
// In main.js or a setup function:
const titleScene = new TitleScene();
const gameScene = new GameScene();

engine.sceneManager.register('TitleScene', titleScene);
engine.sceneManager.register('GameScene', gameScene);

// Start with title
engine.sceneManager.switchTo('TitleScene');

// Later, from within a scene:
this.sceneManager.switchTo('GameScene');
```

## Drawing Custom Objects on Layers
```javascript
// Any object with render(ctx) can be added to a layer
const scoreDisplay = {
  score: 0,
  render: (ctx) => {
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 64px Arial';
    ctx.textAlign = 'right';
    ctx.fillText(`Score: ${this.score}`, 1040, 80);
  }
};
this.layerManager.addToLayer(scoreDisplay, 'TEXT');
```

## Frame-Rate Independent Movement
```javascript
update(deltaTime) {
  // deltaTime is in SECONDS
  // Move 200 pixels per second
  this.player.x += 200 * deltaTime;
  
  // Rotate 1 radian per second
  this.player.rotation += 1 * deltaTime;
}
```

================================================================================
QUICK REFERENCE
================================================================================

Canvas size: 1080 Ã— 1920
Coordinate origin: Top-left (0, 0)
deltaTime unit: Seconds (not milliseconds)
Layer names: BG_FAR, BG_NEAR, VIDEO_IMAGE, SHAPES, SPRITES, TEXT, UI_BUTTONS

Key imports:
- import { Engine } from './core/Engine.js';
- import { Scene } from './scenes/Scene.js';
- import { Sprite } from './entities/Sprite.js';
- import { Button } from './entities/Button.js';

Development: npm run dev (port 5174)
Production build: npm run build (outputs to /dist)

================================================================================
EMBEDDED MODE (GameDev UI Integration)
================================================================================

The Engine can run in "embedded mode" for live testing from the GameDev UI.
This is triggered by the URL parameter: ?embedded=true

In embedded mode:
- Engine waits for commands via postMessage
- Shows "Ready" screen until scene is loaded
- Sends debug info back to parent window

## Incoming Messages (from GameDev UI)

LOAD_SCENE_CONFIG { sceneName, canvasSize, assets, states }
  - Creates ConfigurableScene from JSON config
  - Registers and switches to scene

START_ENGINE
  - Starts the game loop

STOP_ENGINE
  - Stops the game loop

SWITCH_STATE { stateName }
  - Changes to specific state in current scene

GET_DEBUG_INFO
  - Triggers debug info broadcast

## Outgoing Messages (to GameDev UI)

ENGINE_READY { width, height }
  - Sent when engine initializes in embedded mode

ENGINE_STARTED
  - Sent when game loop starts

ENGINE_STOPPED
  - Sent when game loop stops

SCENE_LOADED { sceneName, states }
  - Sent when scene is loaded from config

STATE_CHANGED { stateName }
  - Sent when state changes

DEBUG_INFO { isRunning, sceneName, stateName, fps, layerCounts, totalEntities }
  - Sent periodically (every 500ms) while running

ERROR { message }
  - Sent when an error occurs

## ConfigurableScene (src/js/scenes/ConfigurableScene.js)

Special scene class that can be configured from JSON at runtime.
Used by GameDev UI to test scenes without generating JS files.

Methods:
- loadFromConfig(config) - Parse JSON and setup scene
- getCurrentStateName() - Get current state name
- getEntity(id) - Get entity by ID
- _switchToState(stateName) - Change to specific state

Supports:
- Dynamic entity creation (sprite, button, text, shape)
- State machine with timer/button transitions
- Animations (fadeIn, fadeOut, slideIn, slideOut, scale, pulse)
- Asset loading/unloading

## Testing with Embedded Mode

1. Start Engine: cd Engine && npm run dev
2. Start GameDev UI: cd SceneEditor && npm run dev
3. Open GameDev UI â†’ Create scene â†’ Click "Test"
4. Scene loads in Engine iframe via postMessage

================================================================================
GAMEDEV UI COMPATIBILITY (CRITICAL FOR VIBECODING)
================================================================================

When vibecoding a game, you MUST follow these rules so the GameDev UI can
edit, organize, and run your game. The UI expects a specific project structure.

## Project File Format (SceneEditor/projects/{game}.json)

{
  "name": "My Game",
  "version": "1.0.0",
  "canvas": { "width": 1080, "height": 1920 },
  "startLevel": 0,
  "levels": [
    { "id": "level_0", "name": "Title", "number": 0, "sceneNames": ["Title_Scene_1"] },
    { "id": "level_1", "name": "Level 1", "number": 1, "sceneNames": ["L1_Scene_1"] }
  ],
  "scenes": [...],
  "assets": { "images": [], "audio": [], "fonts": [] },
  "gameObjects": [],
  "build": { "target": "mobile", "platforms": ["android", "ios"] }
}

## Scene Naming Convention (MUST FOLLOW)

| Level Type      | Naming Pattern   | Examples                     |
|-----------------|------------------|------------------------------|
| Title (Level 0) | Title_Scene_{N}  | Title_Scene_1, Title_Scene_2 |
| Gameplay Levels | L{N}_Scene_{M}   | L1_Scene_1, L2_Scene_1       |

Rules:
- Level 0 is ALWAYS the title/menu level
- Level 1+ are gameplay levels
- Scenes within a level increment: L1_Scene_1, L1_Scene_2, L1_Scene_3
- When adding a scene to Level N, use the next number: L{N}_Scene_{nextNum}

## Levels Structure

Levels group scenes together for organization and progression:

levels: [
  {
    "id": "level_0",        // Unique identifier
    "name": "Title",        // Display name (shown as "Title (Level 0)" in UI)
    "number": 0,            // Level number (0 = title level)
    "description": "...",   // Optional description
    "sceneNames": [         // Scenes in this level
      "Title_Scene_1"
    ]
  },
  {
    "id": "level_1",
    "name": "Game",         // Display name (shown as "Game (Level 1)" in UI)
    "number": 1,
    "description": "First gameplay level",
    "sceneNames": [
      "L1_Scene_1",
      "L1_Scene_2"
    ]
  }
]

## Level Display Convention (MUST FOLLOW)

In the UI, levels are displayed with their level number in parentheses for clarity:
- All levels: "{name} (Level {N})" - e.g., "Title (Level 0)", "Game (Level 1)", "Boss (Level 2)"

This helps users understand the level's position in the game structure.

## Engine Messages for Levels

LOAD_LEVEL { levelNumber, levelName, scenes, canvasSize, startScene }
  - Load all scenes for a specific level
  - Clears existing scenes first
  - Switches to startScene

SWITCH_LEVEL { levelNumber, levelName, scenes, canvasSize, startScene }
  - Switch to a different level during gameplay
  - Used for level progression

LEVEL_LOADED { levelNumber, levelName, sceneCount, startScene }
  - Response when level is loaded

LEVEL_CHANGED { levelNumber, levelName, startScene }
  - Response when level is switched

================================================================================
MOBILE DEPLOYMENT (NEW in v2.0)
================================================================================

The Engine now supports Capacitor for building Android (and iOS) apps.

## Configuration

capacitor.config.json:
{
  "appId": "com.gamedev.engine",
  "appName": "GameDev Engine",
  "webDir": "dist"
}

## NPM Scripts (package.json)

- npm run dev           - Start Vite dev server (port 5174)
- npm run build         - Build + copy scenes to dist
- npm run build:android - Build + sync to Capacitor Android
- npm run open:android  - Open Android Studio
- npm run run:android   - Build and run on device

## Auto-Load Game Manifest

When the Engine starts (not in embedded mode), it attempts to load /scenes/game-manifest.json.
If found, it loads the startScene automatically. Otherwise, BootScene is shown.

game-manifest.json (in Engine/public/scenes/):
{
  "name": "My Game",
  "version": "1.0.0",
  "startScene": "TitleScene",
  "scenes": ["TitleScene", "GameScene", "GameOverScene"],
  "useCustomScenes": false
}

## TWO DEVELOPMENT WORKFLOWS

The engine supports two types of games:

### 1. JSON-Driven Games (useCustomScenes: false)
- Scenes are defined by JSON files in Engine/public/scenes/
- Engine uses ConfigurableScene to parse and render them
- Ideal for simple games built entirely in the SceneEditor UI
- Export from SceneEditor UI creates the JSON files

### 2. Custom JavaScript Scenes (useCustomScenes: true)
- Scenes are JavaScript classes extending Scene (e.g., PongScene.js)
- Registered in main.js via loadCustomScenes()
- Full control over game logic, physics, AI
- Ideal for complex gameplay (Pong, Breakout, action games)

**CRITICAL**: The `useCustomScenes` flag tells the Engine which loader to use.
If you vibecode a game with custom JS scenes, you MUST:

1. Set `useCustomScenes: true` in the SceneEditor project file (projects/*.json)
2. The server.js export-game endpoint will preserve this flag in game-manifest.json
3. Custom scene classes must be imported and mapped in main.js customSceneMap
4. The Debug Panel also respects this flag for in-UI testing

**Without this flag, the game will freeze** because the Engine tries to load
JSON configs instead of using your custom JS scene classes.

**Example main.js setup for custom scenes:**
```javascript
import { PongScene } from './scenes/PongScene.js';
import { PongTitleScene } from './scenes/PongTitleScene.js';

async function loadCustomScenes(engine, manifest) {
  const customSceneMap = {
    'Title_Scene_1': PongTitleScene,
    'L1_Scene_1': PongScene
  };
  for (const sceneName of manifest.scenes) {
    const SceneClass = customSceneMap[sceneName];
    if (SceneClass) {
      const scene = new SceneClass();
      engine.sceneManager.register(sceneName, scene);
    }
  }
  if (manifest.startScene) {
    await engine.sceneManager.switchTo(manifest.startScene);
  }
}
```

> [!IMPORTANT]
> **Path Strictness**: All scenes and manifests MUST be in `Engine/public/scenes/` to be served by Vite. Root `Engine/scenes/` is NOT served.

## Common Pitfalls & Optimization

| Issue | Resolution |
|-------|------------|
| **Invisible Assets** | Assets MUST be in `Engine/public/assets/`. Use `assetId` or `spriteId` consistently. |
| **Coordinate Mismatch** | Engine uses **center-based** coordinates for Sprites/Buttons. UI uses top-left for some shapes. Always verify `_createEntity` logic. |
| **Layer Mismatches** | Only use valid layers: `BG_FAR`, `BG_NEAR`, `VIDEO_IMAGE`, `SHAPES`, `SPRITES`, `TEXT`, `UI_BUTTONS`. |
| **Race Conditions** | In custom scene logic, fetch entity references in `populateLayers()`, NOT `enter()`, to ensure they exist. |
| **Black Screen** | Usually a manifest error or a script error in `main.js`. Check the browser console first. |

## Mobile Performance (Capacitor/Play Store)

These patterns are optimized for 60fps on mobile WebViews.

### Power Saving
The Engine automatically pauses the game loop when the app is backgrounded via `visibilitychange` listener. No action needed.

### Anti-Pattern Audit Results (2026-01-17)
| Pattern | Status | Notes |
|---------|--------|-------|
| `shadowBlur` | âœ… Not used | Expensive on mobile. Use offset shapes or pre-rendered PNGs if shadows needed. |
| `globalAlpha` | âœ… Safe usage | Used in Sprite.js, Button.js but wrapped in `ctx.save()`/`ctx.restore()`. |
| SVG-in-Canvas | âœ… Not used | If needed, render to OffscreenCanvas once, then `drawImage()`. |

### Best Practices for Vibecoding
- **NO `ctx.shadowBlur`** â€” Use a semi-transparent shape drawn offset instead.
- **NO per-frame SVG drawing** â€” Cache to OffscreenCanvas first.
- **Group objects by opacity** if many share the same alpha value.
- **Use ObjectPool** for high-frequency spawns (particles, bullets) to avoid GC spikes.

The tryLoadGameManifest() function in main.js handles this.

## First-time Setup

cd Engine
npm install
npx cap add android

## Build Workflow

1. Export scenes from GameDev UI (creates Engine/public/scenes/*.json)
2. Run: npm run build:android
3. Open Android Studio: npm run open:android
4. Click â–¶ Run in Android Studio â†’ app runs on phone

================================================================================
VIBECODER OUTPUT FORMAT (REQUIRED FOR UI EDITING)
================================================================================

When vibecoding ANY game actor, ALWAYS generate BOTH files together:

1. ActorName.js         - The JavaScript implementation
2. ActorName.variables.json - UI-editable properties with min/max/step

WITHOUT the .variables.json file, GameDev UI cannot edit the actor!

## Enhanced Variable Schema

```json
{
  "actorId": "Ball",
  "category": "Gameplay",
  "variables": {
    "speed": {
      "type": "number",
      "default": 500,
      "min": 100,
      "max": 1500,
      "step": 50,
      "label": "Ball Speed",
      "group": "Movement"
    },
    "size": {
      "type": "number", 
      "default": 30,
      "min": 10,
      "max": 100,
      "step": 5,
      "label": "Ball Size",
      "group": "Appearance"
    },
    "color": {
      "type": "color",
      "default": "#ffffff",
      "label": "Ball Color",
      "group": "Appearance"
    },
    "bounceEnabled": {
      "type": "boolean",
      "default": true,
      "label": "Enable Bouncing",
      "group": "Physics"
    }
  }
}
```

## Variable Types

| Type    | UI Control    | Required Properties         |
|---------|---------------|----------------------------|
| number  | Slider        | min, max, step             |
| boolean | Toggle        | -                          |
| string  | Text input    | maxLength (optional)       |
| color   | Color picker  | -                          |
| select  | Dropdown      | options: ["a", "b", "c"]   |

## Reading Variables in Actor JS

```javascript
// In Ball.js init():
async loadConfig() {
  try {
    const res = await fetch('/data/actors/Ball.variables.json');
    const config = await res.json();
    // Apply defaults
    Object.entries(config.variables).forEach(([key, def]) => {
      this[key] = def.default;
    });
  } catch (e) {
    // Fallback to hardcoded defaults
    this.speed = 500;
    this.size = 30;
  }
}
```

## Checklist When Vibecoding an Actor

- [ ] Create ActorName.js with loadConfig() method
- [ ] Create ActorName.variables.json with all tunable properties
- [ ] Include min/max/step for ALL number variables
- [ ] Group related variables (Movement, Appearance, Physics, etc.)
- [ ] Use descriptive labels for UI display

================================================================================
DATA-FIRST DEVELOPMENT (FOR AI VIBECODING)
================================================================================

CRITICAL: When vibecoding a game for this engine, you MUST create COMPLETE
documentation FIRST or CONCURRENTLY with the game code. The GameDev UI 
reads these files to enable visual editing. NO REVERSE ENGINEERING NEEDED.

More documentation is ALWAYS better. Document everything at every stage.

================================================================================
THE 4-STAGE DOCUMENTATION PROCESS
================================================================================

## STAGE 1: PLANNING (Before Any Code)

Create these files FIRST:

/data/
â”œâ”€â”€ manifest.json           # Game overview
â”œâ”€â”€ design.json             # Game design document
â”œâ”€â”€ actors/                 # Actor definitions (one per actor)
â”œâ”€â”€ logic/                  # Logic node graphs (one per actor)
â”œâ”€â”€ scenes/                 # Scene definitions
â”œâ”€â”€ states/                 # State machine definitions
â””â”€â”€ assets.json             # Asset manifest

### 1.1 manifest.json (Required)
{
  "gameName": "My New Game",
  "description": "High-level description of the game concept",
  "version": "1.0.0",
  "canvas": { "width": 1080, "height": 1920 },
  "actors": ["ActorA", "ActorB"],
  "scenes": ["TitleScene", "MainScene"],
  "startScene": "TitleScene",
  "createdAt": "2026-01-16T00:00:00Z"
}

### 1.2 design.json (Required - Game Design Document)
{
  "overview": "Detailed breakdown of core gameplay loops and mechanics",
  "mechanics": [
    {
      "name": "Core Interaction",
      "description": "How the user interacts with the game",
      "actors": ["ActorA"],
      "triggers": ["OnTouch", "OnCollision"]
    }
  ],
  "winCondition": "Description of how the player wins",
  "loseCondition": "Description of how the game ends",
  "progression": "How the difficulty or level changes over time"
}

### 1.3 actors/{ActorId}.json (One file per actor)
{
  "id": "ActorId",
  "type": "entity_type",
  "description": "What this actor does in the game",
  "layer": "SPRITES",
  "sprite": {
    "shape": "rect|circle",
    "width": 100,
    "height": 100,
    "color": "#ffffff",
    "assetId": null
  },
  "variables": {
    "positionX": { 
      "type": "number", 
      "default": 540, 
      "min": 0, 
      "max": 1080, 
      "step": 10,
      "label": "Start X",
      "group": "Position"
    },
    "positionY": { 
      "type": "number", 
      "default": 960, 
      "min": 0, 
      "max": 1920, 
      "step": 10,
      "label": "Start Y",
      "group": "Position"
    },
    "speed": { 
      "type": "number", 
      "default": 500, 
      "min": 100, 
      "max": 1500, 
      "step": 50,
      "label": "Movement Speed",
      "group": "Movement"
    }
  },
  "tags": ["tag1", "tag2"],
  "collidesWith": ["OtherActor"],
  "behaviors": ["behavior_name"]
}

### 1.4 logic/{ActorId}.logic.json (One file per actor - CRITICAL FOR NODE EDITOR)

**IMPORTANT**: Logic sheets power the visual Node Editor in the GameDev UI. Create comprehensive
logic graphs to enable visual editing and AI code generation.

**Node Types:**
| Type | Subtypes | Description |
|------|----------|-------------|
| event | OnUpdate, OnStart, OnCollision, OnTouch, OnOutOfBounds | Entry points that trigger logic |
| action | Move, SetPosition, Bounce, PlaySound, AddScore, ResetPosition, GetActorPosition | Execute changes |
| variable | GetVariable, SetVariable | Read/write actor variables |
| logic | Add, Multiply, Clamp, Lerp, Compare | Mathematical operations |
| flow | Branch, Sequence | Control flow and conditionals |

**Example - Complete Ball Logic:**
```json
{
  "actorId": "Ball",
  "description": "Ball movement, collision, and scoring logic.",
  "nodes": [
    { "id": "var_speed", "type": "variable", "subtype": "GetVariable",
      "position": { "x": 50, "y": 50 },
      "outputs": [{ "id": "value", "type": "number", "label": "speed" }],
      "properties": { "variableName": "speed", "defaultValue": 8 } },
    { "id": "e_update", "type": "event", "subtype": "OnUpdate",
      "position": { "x": 280, "y": 50 },
      "outputs": [{ "id": "exec", "type": "execution" }] },
    { "id": "a_move", "type": "action", "subtype": "Move",
      "position": { "x": 500, "y": 50 },
      "inputs": [{ "id": "exec", "type": "execution" }] },
    { "id": "e_collision", "type": "event", "subtype": "OnCollision",
      "position": { "x": 280, "y": 200 },
      "outputs": [{ "id": "exec", "type": "execution" }],
      "properties": { "targetTag": "paddle" } },
    { "id": "a_bounce", "type": "action", "subtype": "Bounce",
      "position": { "x": 500, "y": 200 },
      "inputs": [{ "id": "exec", "type": "execution" }] },
    { "id": "e_out", "type": "event", "subtype": "OnOutOfBounds",
      "position": { "x": 280, "y": 350 },
      "outputs": [{ "id": "exec", "type": "execution" }] },
    { "id": "f_scorer", "type": "flow", "subtype": "Branch",
      "position": { "x": 500, "y": 350 },
      "inputs": [{ "id": "exec", "type": "execution" }, { "id": "condition", "type": "boolean" }],
      "outputs": [{ "id": "true", "type": "execution" }, { "id": "false", "type": "execution" }] },
    { "id": "a_score", "type": "action", "subtype": "AddScore",
      "position": { "x": 720, "y": 350 },
      "inputs": [{ "id": "exec", "type": "execution" }] }
  ],
  "connections": [
    { "id": "c1", "from": { "nodeId": "e_update", "outputId": "exec" }, "to": { "nodeId": "a_move", "inputId": "exec" } },
    { "id": "c2", "from": { "nodeId": "e_collision", "outputId": "exec" }, "to": { "nodeId": "a_bounce", "inputId": "exec" } },
    { "id": "c3", "from": { "nodeId": "e_out", "outputId": "exec" }, "to": { "nodeId": "f_scorer", "inputId": "exec" } },
    { "id": "c4", "from": { "nodeId": "f_scorer", "outputId": "true" }, "to": { "nodeId": "a_score", "inputId": "exec" } }
  ]
}
```

> [!TIP]
> Always include variable nodes with `defaultValue` for properties like speed, direction, health, etc.
> These become editable in the Node Editor UI.


### 1.5 scenes/{SceneName}.scene.json (One file per scene)
{
  "sceneName": "MainScene",
  "description": "Environment and setup for the gameplay",
  "actors": ["ActorA", "ActorB"],
  "backgroundAsset": null,
  "backgroundColor": "#1a1a2e",
  "layers": {
    "BG_FAR": [],
    "SPRITES": ["ActorA"],
    "TEXT": ["ActorB"],
    "UI_BUTTONS": []
  },
  "initialState": "PLAYING",
  "states": ["PLAYING", "PAUSED"]
}

### 1.6 states/{SceneName}.states.json (State machines per scene)
{
  "sceneName": "MainScene",
  "states": [
    {
      "name": "PLAYING",
      "description": "Normal gameplay state",
      "activeActors": ["ActorA"],
      "transitions": [
        { "trigger": "customEvent", "nextState": "PAUSED" }
      ]
    },
    {
      "name": "PAUSED",
      "description": "Game paused",
      "duration": 0,
      "transitions": [
        { "trigger": "resume", "nextState": "PLAYING" }
      ]
    }
  ]
}

### 1.7 assets.json (All assets used)
{
  "images": [
    { "id": "sprite_a", "path": "/assets/images/actor_a.png", "usedBy": ["ActorA"] }
  ],
  "audio": [
    { "id": "bg_music", "path": "/assets/music/bgm.mp3", "type": "music" },
    { "id": "hit_sound", "path": "/assets/sfx/hit.mp3", "usedBy": ["Ball.OnCollision"] },
    { "id": "score_sound", "path": "/assets/sfx/score.mp3", "usedBy": ["GameScene.POINT_SCORED"] }
  ]
}


================================================================================
STAGE 2: IMPLEMENTATION (Code + Comments)
================================================================================

When writing code, ALWAYS reference the data files:

```javascript
/**
 * Ball Actor Implementation
 * Data file: /data/actors/Ball.json
 * Logic file: /data/logic/Ball.logic.json
 * 
 * Variables (from Ball.json):
 * - positionX, positionY: Current position
 * - directionX, directionY: Movement direction (-1 or 1)
 * - speed: Movement speed in px/sec
 * 
 * Logic (from Ball.logic.json):
 * - OnUpdate â†’ Move (uses direction * speed * deltaTime)
 * - OnCollision(Wall) â†’ FlipDirection(directionX)
 * - OnCollision(Paddle) â†’ FlipDirection(directionY) â†’ PlaySound â†’ IncreaseSpeed
 */
class Ball {
  // Implementation that matches the documented logic
}
```

================================================================================
STAGE 3: CROSS-REFERENCE VALIDATION
================================================================================

After implementing, create a validation file:

/data/validation.json
{
  "validated": true,
  "timestamp": "2026-01-16T00:00:00Z",
  "actors": {
    "Player": {
      "jsonFile": "/data/actors/Player.json",
      "logicFile": "/data/logic/Player.logic.json",
      "codeFile": "ConfigurableScene (built-in)",
      "variablesMatch": true,
      "logicMatch": true
    }
  },
  "scenes": {
    "L1_Scene_1": {
      "jsonFile": "/data/scenes/L1_Scene_1.scene.json",
      "codeFile": "ConfigurableScene (built-in)",
      "actorsMatch": true,
      "statesMatch": true
    }
  }
}

================================================================================
STAGE 4: CHANGE LOG
================================================================================

When making changes, update /data/changelog.json:

{
  "changes": [
    {
      "timestamp": "2026-01-16T01:00:00Z",
      "type": "add",
      "actor": "PowerUp",
      "description": "Added power-up item",
      "filesCreated": [
        "/data/actors/PowerUp.json",
        "/data/logic/PowerUp.logic.json"
      ],
      "scenesModified": ["L1_Scene_1"]
    }
  ]
}

================================================================================
THE 5 NODE TYPES
================================================================================

| Type      | Color    | Purpose                          | Examples                          |
|-----------|----------|----------------------------------|-----------------------------------|
| event     | ðŸ”´ Red   | Triggers logic chains            | OnUpdate, OnCollision, OnClick    |
| variable  | ðŸŸ¢ Green | Read/write data                  | GetSpeed, SetPosition             |
| logic     | ðŸŸ¡ Yellow| Calculate/compare                | NOT, AND, GreaterThan, Add        |
| flow      | ðŸŸ  Orange| Decision making                  | Branch, Loop, Delay               |
| action    | ðŸ”µ Blue  | Do something in game             | Move, PlaySound, SpawnActor       |

================================================================================
COMPLETE EXAMPLE: GAME VIBECODING WORKFLOW
================================================================================

When asked to create a game, your COMPLETE workflow is:

1. CREATE project JSON in SceneEditor/projects/{gamename}.json with:
   - levels: [{id: level_0, sceneNames: ["Title_Scene_1"]}, {id: level_1, sceneNames: ["L1_Scene_1"]}]
   - scenes: [Title_Scene_1, L1_Scene_1]
   - Scene names MUST follow: Title_Scene_{N}, L{N}_Scene_{M}

2. CREATE /data/manifest.json (game overview, actor list)
3. CREATE /data/design.json (mechanics, win condition)
4. CREATE /data/actors/{ActorId}.json (variables with descriptions)
5. CREATE /data/logic/{ActorId}.logic.json (full node graph)
6. CREATE more actors as needed...
7. CREATE /data/scenes/Title_Scene_1.scene.json (title screen)
8. CREATE /data/scenes/L1_Scene_1.scene.json (first gameplay scene)
9. CREATE /data/states/{SceneName}.states.json (state machines)
10. CREATE /data/assets.json (all images and audio)
11. All scenes use ConfigurableScene (no custom JS needed for simple games)
12. CREATE /data/validation.json (confirm data matches implementation)

================================================================================
WHY THIS MATTERS
================================================================================

The GameDev UI reads ALL of /data/ to provide:
- Complete actor list with all editable variables
- Visual node graphs showing exact logic flows
- Scene structure and state machines
- Asset usage tracking
- Real-time editing with full context

If ANY data file is missing, modding capability is reduced.

MORE DOCUMENTATION = BETTER MODDING EXPERIENCE


================================================================================
AI Behavior & Trigger Rules
================================================================================

Project Documentation Files (in project root):
- TODO.md      - Task list with priorities and completion status
- PROGRESS.md  - Chronological log of changes and current state
- NOTES.md     - Architecture decisions, file locations, quick reference


Trigger: [Handover Protocol]

Activation Words: "bye", "done", "handover", "handoff", "back soon", "finished", "save"

Action: Immediately update PROGRESS.md with today's changes and TODO.md with the next task. Summarize the status in 2 sentences. Do not ask for permission; just do it.

Trigger: [Briefing Protocol]

Activation Words: "hi", "hello", "morning", "let's go", "yo"

Action: Read llms.txt, TODO.md, NOTES.md, and the last entry of PROGRESS.md. State exactly where we left off and what the immediate next step is.

================================================================================
END OF LLM CONTEXT FILE
================================================================================
